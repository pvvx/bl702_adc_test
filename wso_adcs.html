<!DOCTYPE html>
<html>
  <head>
	<!-- style type="text/css"></style -->
	<title>Get ADC data</title>
  </head>
  <body>
	<div style="height:auto;width:auto;text-align:center;">
	<table style="width:100%;padding:0px;">
	<tr>
		<td id='div_v' style="width:100%;">
		<canvas id='scope'></canvas>
		</td><td>
		<input id='ysync' type="range" min="0" max="1.0" step="0.000001" style="width:10px;-webkit-appearance:slider-vertical;">
		</td>
	</tr>
	<tr><td>
		<input id='xsync' type="range" min="0" max="1.0" step="0.000001" style="width:100%;">
	</td><td>
	</td></tr>
	<table>
		Window: <span id='wdsize'>?</span> sec, Sample Rate: <span id='smprate'>?</span> smps
	<div>
		<span id='labdiv'>?</span>
		<input type="button" id="butOpen" value="Open">
		<input type="button" id="butOnOff" value="Stop">
		<input type="button" id="butSave" value="Save data.csv"><br>
	</div>
	</div>
  </body>
<script type="text/javascript">
"use strict";
var $ = function(id) {
	return document.getElementById(id);
}
function delay(ms) {
  return new Promise((resolve, reject) => {
	setTimeout(resolve, ms);
  });
}
function hex(number, length) {
	var str = (number.toString(16)).toUpperCase();
	while (str.length < length) str = '0' + str;
	return str;
}
class SerialController {
	async init(init_cb) {
		if ('serial' in navigator) {
			try {
				this.port = await navigator.serial.requestPort();
				console.log('USB-COM open.');
				await this.port.open({baudRate: 115200, baudrate: 115200});
				this.writer = this.port.writable.getWriter();
		        this.reader = this.port.readable.getReader();
				console.log('DTR off, RTS off.');
				await this.port.setSignals({dataTerminalReady: false, requestToSend: false});
				//await delay(10);
				//console.log('RTS on.');
				//await this.port.setSignals({requestToSend: false});
				if (typeof init_cb == 'function') init_cb(this.port);
			}
			catch (err) {
				console.error('There was an error opening the serial port:', err);
			}
		}
		else {
			console.error('Web serial doesn\'t seem to be enabled in your browser. Try enabling it by visiting:');
			console.error('chrome://flags/#enable-experimental-web-platform-features');
			console.error('opera://flags/#enable-experimental-web-platform-features');
			console.error('edge://flags/#enable-experimental-web-platform-features');
			alert('Web serial doesn\'t seem to be enabled in your browser. Try enabling it by visiting:\r\nchrome://flags/#enable-experimental-web-platform-features\r\nopera://flags/#enable-experimental-web-platform-features\r\nedge://flags/#enable-experimental-web-platform-features');
			// chrome://device-log
		}
	}
	async setdtrrts(dtr, rts) {
		console.log('DTR='+dtr+', RTS='+rts+'.');
		await this.port.setSignals({dataTerminalReady: dtr, requestToSend: rts});
	}
	async write_raw(data) {
		return await this.writer.write(data);
	}
	async read_raw_all(add_data_cb) {
		try {
	        // this.reader = this.port.readable.getReader();
			while (true) {
				const { value, done } = await this.reader.read();
				if (done) {
					// console.log('|reader| has been canceled.');
			        break;
				}
				// Do something with |value|...
				if (typeof add_data_cb == 'function') add_data_cb(value);
			}
		}
		catch (err) {
			console.error('Error reading data:', err);
		}
	}
	async reset(t_ms) {
		console.log('DTR, RTS off.');
		await this.port.setSignals({dataTerminalReady: true, requestToSend: true});
		await delay(t_ms);
		console.log('DTR, RTS on.');
		return await this.port.setSignals({dataTerminalReady: false, requestToSend: false});
	}
	async close() {
		await this.writer.close();
		await this.reader.cancel();
		await this.port.close();
		console.log('USB-COM close.');
	}
}
var serialController = new SerialController();
const connect = $('butOpen');
async function DeviceStart() {
	connect.value = 'Close';
	console.log('Device: StopADC...');
	serialController.setdtrrts(false, false);
	await delay(50);
	blk = new Uint8Array(); // flush RX
    console.log('Start ADC.');
	serialController.setdtrrts(true, true);
	if(!sttim) {
		sttim = new Date().getTime();
		sitim = setInterval(function(){wsSmpRate()}, 500);
	}
	serialController.read_raw_all(DeviceRead);
}
async function DeviceStop() {
	console.log('Device: StopADC...');
	serialController.setdtrrts(false, false);
	await delay(10);
	serialController.close();
	if(sttim != 0) {
		clearInterval(sitim);
		sttim = 0;
	}
	cur_idx = 0;
	old_idx = 0;
	smpsa = [];
	data_ch1 = [];
	frend = 0;
	blk = new Uint8Array(); // flush RX
}
connect.addEventListener('pointerdown', () => {
	if(connect.value == 'Close') {
		DeviceStop();
		connect.value = 'Open';
	} else {
		serialController.init(DeviceStart);
	}
});
//**************************************
const smprate = 31250;
//const levelRisingEdge = 30000 // 32768
//**************************************
var smps = smprate;
var sttim = 0;
var sitim;
var cur_idx = 0;
var old_idx = 0;
var smpsa = [];
var frend = 0;
function wsSmpRate() {
	var idx = cur_idx, tt = new Date().getTime();
	var sps = (idx - old_idx) * 1000/ (tt - sttim);
	sttim = tt;	old_idx = idx;
	smpsa.push(sps);
	var len = smpsa.length;
	if(len > 100) { smpsa.shift(); len-- };
	var csps = 0;
	for (var i = 0; i < len; i++) csps += smpsa[i];
	csps = csps/len;
	$('smprate').innerHTML = csps.toFixed(1);
	$('labdiv').innerHTML = 'Render ' + frend + ' Hz';
	frend = 0;
}
var rend = true;
$("butOnOff").onclick =  function() {
	if(rend) {rend = false; $("butOnOff").value = "Run";}
	else {rend = true; $("butOnOff").value = "Stop";}
}
var data_ch1 = [];
var showData1 = [];
var ctx = $('scope').getContext('2d');
window.onresize = function(){
	let h = (window.innerHeight-100)&(-2);
	ctx.canvas.height = h;
	$('ysync').style.height = h + 'px';
	let w = ($('div_v').clientWidth-20)&(-2);
	if(w > window.innerWidth-50)
		w = (window.innerWidth-50)&(-2);
	ctx.canvas.width = w;
	$('wdsize').innerHTML = w/smprate;
	$('xsync').style.width = w + 'px';
}
window.onresize();
function draw() {
	let width = ctx.canvas.width;
	let height = ctx.canvas.height;
	let levelRisingEdge = Math.round($('ysync').value * 65536);
	let _xsync = Math.round($('xsync').value * width);
	let xsync_ = width - _xsync;
	let scaling = height / 65536;
	let przdg = 0;

	ctx.fillStyle = 'rgba(0, 20, 0, 0.2)';
	ctx.fillRect(0, 0, width, height);


	ctx.beginPath();
	ctx.strokeStyle = 'rgb(0, 255, 0)';
	ctx.lineWidth = 1;
	ctx.setLineDash([]);

	let dsize = data_ch1.length;
	let ssize;
	if (dsize > width*2) {
		przdg = _xsync;
		while (data_ch1[przdg] > levelRisingEdge-1 && przdg <= dsize - xsync_) przdg++;
		while (data_ch1[przdg] < levelRisingEdge+1 && przdg <= dsize - xsync_) przdg++;
		if (przdg > 0 && przdg < dsize - xsync_) {
			showData1 = data_ch1.slice(przdg - _xsync, przdg + xsync_);
			if(dsize > width*4)
				data_ch1 = data_ch1.slice(dsize - width*2);
			else
				data_ch1 = data_ch1.slice(przdg + xsync_);
		} else if(dsize > width*4)
			data_ch1 = data_ch1.slice(dsize - width*2);
	}
	for (let x = 0; x < showData1.length && x < width; x++)
	ctx.lineTo(x, height - showData1[x] * scaling);
	ctx.stroke();

	ctx.beginPath();
	ctx.lineWidth = 0.1;
	ctx.strokeStyle = 'rgb(155, 155, 155)';
	ctx.setLineDash([5,4]);
	ctx.moveTo(0, height - levelRisingEdge * scaling);
	ctx.lineTo(width, height - levelRisingEdge * scaling);
	ctx.moveTo(_xsync, 0);
	ctx.lineTo(_xsync, height);
	ctx.stroke();
	frend++;
	requestAnimationFrame(draw);
}
draw();

var start_adc_ok = false;
var blk;
function DeviceRead(data) {
	function concatTypedArrays(a, b) { // a, b TypedArray of same type
		let c = new (b.constructor)(a.length + b.length);
	    c.set(a, 0);
	    c.set(b, a.length);
	    return c;
	}
	if(data instanceof Uint8Array) {
		blk = concatTypedArrays(blk, data);
		while(blk.length > 1) {
			let blksz = blk[0];
			if (blk.length < blksz + 2)	return;
			let blkid = blk[1];
			if (blkid == 0x0A) { // adc data
				for (var i=0; i<blksz; i+=2) {
					if(rend)
						data_ch1.push([blk[i+2] | (blk[i+3]<<8)]);
					cur_idx++;
				}
			} else
				console.log('Error blk:', blk.slice(0,blksz+2));
			blk = blk.slice(blksz+2);
		}
	} else console.log('Device data?', data);
}
function convertArrayOfObjectsToCSV(value){
	var result, ctr, keys, columnDelimiter, lineDelimiter, data;

	data = value.data || null;
	if (data == null || !data.length) {return null;}
	columnDelimiter = value.columnDelimiter || ';';
	lineDelimiter = value.lineDelimiter || '\n';
	keys = Object.keys(data[1]);
	result = '';
	result += keys.join(columnDelimiter);
	result += lineDelimiter;
	data.forEach(function(item){
		ctr = 0;
		keys.forEach(function(key){
			if (ctr > 0)
				result += columnDelimiter;
			result += item[key];
			ctr++;
		});
		result += lineDelimiter;
	});
	return result;
}
function download(data, filename, type) {
	let file = new Blob([data], {type: type});
	if (window.navigator.msSaveOrOpenBlob) { // ie10+
		window.navigator.msSaveOrOpenBlob(file, filename);
	} else { // ff, chrome
		let url = URL.createObjectURL(file);
		let a = document.createElement("a");
		a.href = url;
		a.download = filename;
		document.body.appendChild(a);
		a.click();
		setTimeout(function(){document.body.removeChild(a);window.URL.revokeObjectURL(url);},0);
		URL.revokeObjectURL(url);
	}
	//file.close();
}
$("butSave").onclick =  function() {
	let csv = convertArrayOfObjectsToCSV({data: showData1});
	download(csv, 'data.csv', 'text/csv;charset=utf-8');
}
</script>
</html>
